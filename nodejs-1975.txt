const express = require("express");
const app = express();
const axios = require("axios");
const os = require('os');
const fs = require("fs");
const path = require("path");
const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const { execSync } = require('child_process');

// --------------------------------------------------------------------------------
// [重要] 请修改此处为你存放二进制文件的 GitHub 仓库信息
// 仓库内需建立 /bin 文件夹，并放入解压好的 web(xray), bot(cloudflared), agent(nezha)
// 文件命名规则示例 (AMD64): web-linux-amd64, bot-linux-amd64, agent-linux-amd64
// 文件命名规则示例 (ARM64): web-linux-arm64, bot-linux-arm64, agent-linux-arm64
// --------------------------------------------------------------------------------
const GITHUB_REPO = "topsam1975/nodejs-argo1975"; // <--- 请修改这里，例如 "zhangsan/my-nodes"
const GITHUB_BRANCH = "main";                  // 分支名，通常是 main 或 master
const BIN_DIR = "bin";                         // 存放核心的文件夹名

// 环境变量配置
const NAME = process.env.NAME || 'node';
const UUID = process.env.UUID || '663830b8-ee7b-426b-8833-e63bb9999ef0';
const PORT = process.env.SERVER_PORT || process.env.PORT || 3671;
const SUB_PATH = process.env.SUB_PATH || 'letmego';   // 订阅路径
const UPLOAD_URL = process.env.UPLOAD_URL || '';      // 节点或订阅自动上传地址
const PROJECT_URL = process.env.PROJECT_URL || '';    // 项目分配的url
const FILE_PATH = process.env.FILE_PATH || './tmp';   // 运行目录

// 哪吒配置
const NEZHA_SERVER = process.env.NEZHA_SERVER || '';  
const NEZHA_PORT = process.env.NEZHA_PORT || '';
const NEZHA_KEY = process.env.NEZHA_KEY || '';        

// Argo 隧道配置
const ARGO_DOMAIN = process.env.ARGO_DOMAIN || '';          
const ARGO_AUTH = process.env.ARGO_AUTH || '';              
const ARGO_PORT = process.env.ARGO_PORT || 8001;            
const CFIP = process.env.CFIP || 'cdns.doon.eu.org';
const CFPORT = process.env.CFPORT || 443;                   

// 创建运行文件夹
if (!fs.existsSync(FILE_PATH)) {
  fs.mkdirSync(FILE_PATH);
  console.log(`${FILE_PATH} is created`);
} else {
  console.log(`${FILE_PATH} already exists`);
}

// 生成随机文件名工具
function generateRandomName() {
  const characters = 'abcdefghijklmnopqrstuvwxyz';
  let result = '';
  for (let i = 0; i < 6; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

// 全局路径定义
const npmName = generateRandomName(); // 对应 nezha agent
const webName = generateRandomName(); // 对应 xray
const botName = generateRandomName(); // 对应 cloudflared
const phpName = generateRandomName(); // 备用

let npmPath = path.join(FILE_PATH, npmName);
let webPath = path.join(FILE_PATH, webName);
let botPath = path.join(FILE_PATH, botName);
let phpPath = path.join(FILE_PATH, phpName);

let subPath = path.join(FILE_PATH, 'sub.txt');
let listPath = path.join(FILE_PATH, 'list.txt');
let bootLogPath = path.join(FILE_PATH, 'boot.log');
let configPath = path.join(FILE_PATH, 'config.json');

// --------------------------------------------------------------------------------
// [功能 1 & 2] 智能伪装首页 (优先 index.html，否则使用极客模板)
// --------------------------------------------------------------------------------
app.get("/", function(req, res) {
  const customPagePath = path.join(__dirname, 'index.html');

  if (fs.existsSync(customPagePath)) {
    // 策略 A: 如果同目录下存在 index.html，直接显示
    res.sendFile(customPagePath);
  } else {
    // 策略 B: 否则显示内置的极客风格导航页 (替代 Hello World)
    const geekHtml = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的个人导航 | My Portal</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0f0f12; color: #e0e0e0; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }
        .container { text-align: center; max-width: 600px; padding: 40px; background: #1a1a1f; border-radius: 16px; box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5); }
        h1 { font-weight: 300; margin-bottom: 10px; color: #fff; }
        p { color: #888; margin-bottom: 40px; }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .card { background: #25252b; padding: 20px; border-radius: 12px; text-decoration: none; color: #fff; transition: 0.3s; border: 1px solid #333; }
        .card:hover { background: #2f2f38; transform: translateY(-3px); border-color: #4a90e2; }
        .footer { margin-top: 40px; font-size: 12px; color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome Back</h1>
        <p>探索未知的数字世界 / Explore the Digital World</p>
        <div class="grid">
            <a href="https://www.google.com" target="_blank" class="card">Google 搜索</a>
            <a href="https://github.com" target="_blank" class="card">GitHub 仓库</a>
            <a href="https://youtube.com" target="_blank" class="card">YouTube 视频</a>
            <a href="https://chatgpt.com" target="_blank" class="card">AI 助手</a>
        </div>
        <div class="footer">
            &copy; 2025 Personal Navigation. All rights reserved.
        </div>
    </div>
</body>
</html>`;
    res.send(geekHtml);
  }
});

// 清理旧节点逻辑
function deleteNodes() {
  try {
    if (!UPLOAD_URL || !fs.existsSync(subPath)) return;
    let fileContent;
    try {
      fileContent = fs.readFileSync(subPath, 'utf-8');
    } catch { return null; }
    const decoded = Buffer.from(fileContent, 'base64').toString('utf-8');
    const nodes = decoded.split('\n').filter(line => /(vless|vmess|trojan|hysteria2|tuic):\/\//.test(line));
    if (nodes.length === 0) return;

    axios.post(`${UPLOAD_URL}/api/delete-nodes`, JSON.stringify({ nodes }), { headers: { 'Content-Type': 'application/json' } }).catch(() => {});
  } catch (err) {}
}

// 清理旧文件
function cleanupOldFiles() {
  try {
    if (fs.existsSync(FILE_PATH)) {
        const files = fs.readdirSync(FILE_PATH);
        files.forEach(file => {
          try {
            const fullPath = path.join(FILE_PATH, file);
            if (fs.statSync(fullPath).isFile()) fs.unlinkSync(fullPath);
          } catch (e) {}
        });
    }
  } catch (err) {}
}

// 生成 Xray 配置
async function generateConfig() {
  const config = {
    log: { access: '/dev/null', error: '/dev/null', loglevel: 'none' },
    inbounds: [
      { port: ARGO_PORT, protocol: 'vless', settings: { clients: [{ id: UUID, flow: 'xtls-rprx-vision' }], decryption: 'none', fallbacks: [{ dest: 3001 }, { path: "/vless-argo", dest: 3002 }, { path: "/vmess-argo", dest: 3003 }, { path: "/trojan-argo", dest: 3004 }] }, streamSettings: { network: 'tcp' } },
      { port: 3001, listen: "127.0.0.1", protocol: "vless", settings: { clients: [{ id: UUID }], decryption: "none" }, streamSettings: { network: "tcp", security: "none" } },
      { port: 3002, listen: "127.0.0.1", protocol: "vless", settings: { clients: [{ id: UUID, level: 0 }], decryption: "none" }, streamSettings: { network: "ws", security: "none", wsSettings: { path: "/vless-argo" } }, sniffing: { enabled: true, destOverride: ["http", "tls", "quic"], metadataOnly: false } },
      { port: 3003, listen: "127.0.0.1", protocol: "vmess", settings: { clients: [{ id: UUID, alterId: 0 }] }, streamSettings: { network: "ws", wsSettings: { path: "/vmess-argo" } }, sniffing: { enabled: true, destOverride: ["http", "tls", "quic"], metadataOnly: false } },
      { port: 3004, listen: "127.0.0.1", protocol: "trojan", settings: { clients: [{ password: UUID }] }, streamSettings: { network: "ws", security: "none", wsSettings: { path: "/trojan-argo" } }, sniffing: { enabled: true, destOverride: ["http", "tls", "quic"], metadataOnly: false } },
    ],
    dns: { servers: ["https+local://8.8.8.8/dns-query"] },
    outbounds: [ { protocol: "freedom", tag: "direct" }, {protocol: "blackhole", tag: "block"} ]
  };
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
}

// 获取系统架构
function getSystemArchitecture() {
  const arch = os.arch();
  return (arch === 'arm' || arch === 'arm64' || arch === 'aarch64') ? 'arm' : 'amd';
}

// 下载文件
function downloadFile(fileName, fileUrl, callback) {
  if (!fs.existsSync(FILE_PATH)) fs.mkdirSync(FILE_PATH, { recursive: true });
  const writer = fs.createWriteStream(fileName);
  console.log(`Downloading: ${fileUrl} -> ${fileName}`);
  
  axios({ method: 'get', url: fileUrl, responseType: 'stream' })
    .then(response => {
      response.data.pipe(writer);
      writer.on('finish', () => { writer.close(); callback(null, fileName); });
      writer.on('error', err => { 
          fs.unlink(fileName, () => {}); 
          callback(`Download failed: ${err.message}`); 
      });
    })
    .catch(err => callback(`Download failed: ${err.message}`));
}

// --------------------------------------------------------------------------------
// [功能 3] 构建 GitHub Raw 下载链接 (替换不明来源)
// --------------------------------------------------------------------------------
function getFilesForArchitecture(architecture) {
  // 基础 URL: https://raw.githubusercontent.com/用户/仓库/main/bin
  const baseUrl = `https://raw.githubusercontent.com/${GITHUB_REPO}/${GITHUB_BRANCH}/${BIN_DIR}`;
  
  // 架构后缀映射
  const suffix = architecture === 'arm' ? 'linux-arm64' : 'linux-amd64';

  const baseFiles = [
    // web -> xray-linux-amd64/arm64
    { fileName: webPath, fileUrl: `${baseUrl}/web-${suffix}` }, 
    // bot -> cloudflared-linux-amd64/arm64 (命名请保持 bot-...)
    { fileName: botPath, fileUrl: `${baseUrl}/bot-${suffix}` }
  ];

  if (NEZHA_SERVER && NEZHA_KEY) {
      if (NEZHA_PORT) {
          // agent -> agent-linux-amd64/arm64
          baseFiles.unshift({ 
            fileName: npmPath, 
            fileUrl: `${baseUrl}/agent-${suffix}` 
          });
      } else {
          // 兼容旧版 php 模式，如果不需要可忽略
          baseFiles.unshift({ 
            fileName: phpPath, 
            fileUrl: `${baseUrl}/php-${suffix}`
          });
      }
  }

  return baseFiles;
}

// 下载并运行
async function downloadFilesAndRun() {  
  const architecture = getSystemArchitecture();
  const filesToDownload = getFilesForArchitecture(architecture);
  
  if (filesToDownload.length === 0) return console.log(`No files for architecture: ${architecture}`);

  try {
    await Promise.all(filesToDownload.map(fileInfo => {
        return new Promise((resolve, reject) => {
            downloadFile(fileInfo.fileName, fileInfo.fileUrl, (err) => err ? reject(err) : resolve());
        });
    }));
  } catch (err) {
    console.error('Error downloading files:', err);
    return;
  }

  // 授权
  [npmPath, webPath, botPath, phpPath].forEach(p => {
      if (fs.existsSync(p)) fs.chmodSync(p, 0o775);
  });

  // 运行 Nezha
  if (NEZHA_SERVER && NEZHA_KEY) {
      if (!NEZHA_PORT) {
        // V1 Logic (PHP Mode) - 保持原样
         const tls = ['443','8443','2096','2053'].includes(NEZHA_SERVER.split(':').pop()) ? 'true' : 'false';
         const configYaml = `client_secret: ${NEZHA_KEY}\ndebug: false\nserver: ${NEZHA_SERVER}\ntls: ${tls}\nuuid: ${UUID}`;
         fs.writeFileSync(path.join(FILE_PATH, 'config.yaml'), configYaml);
         exec(`nohup ${phpPath} -c "${FILE_PATH}/config.yaml" >/dev/null 2>&1 &`).catch(e => console.error(`php error: ${e}`));
      } else {
        // Agent Logic
        const tlsArgs = ['443', '8443', '2096', '2087', '2083', '2053'].includes(NEZHA_PORT) ? '--tls' : '';
        exec(`nohup ${npmPath} -s ${NEZHA_SERVER}:${NEZHA_PORT} -p ${NEZHA_KEY} ${tlsArgs} --disable-auto-update --report-delay 4 --skip-conn --skip-procs >/dev/null 2>&1 &`)
            .then(() => console.log(`${npmName} (Agent) is running`))
            .catch(e => console.error(`agent error: ${e}`));
      }
  }

  // 运行 Xray (Web)
  exec(`nohup ${webPath} -c ${configPath} >/dev/null 2>&1 &`)
    .then(() => console.log(`${webName} (Xray) is running`))
    .catch(e => console.error(`xray error: ${e}`));

  // 运行 Cloudflared (Bot)
  if (fs.existsSync(botPath)) {
      await new Promise(r => setTimeout(r, 2000));
      let args;
      if (ARGO_AUTH.match(/^[A-Z0-9a-z=]{120,250}$/)) {
          args = `tunnel --edge-ip-version auto --no-autoupdate --protocol http2 run --token ${ARGO_AUTH}`;
      } else if (ARGO_AUTH.match(/TunnelSecret/)) {
          fs.writeFileSync(path.join(FILE_PATH, 'tunnel.json'), ARGO_AUTH);
          fs.writeFileSync(path.join(FILE_PATH, 'tunnel.yml'), `tunnel: ${ARGO_AUTH.split('"')[11]}\ncredentials-file: ${path.join(FILE_PATH, 'tunnel.json')}\nprotocol: http2\ningress:\n  - hostname: ${ARGO_DOMAIN}\n    service: http://localhost:${ARGO_PORT}\n    originRequest:\n      noTLSVerify: true\n  - service: http_status:404`);
          args = `tunnel --edge-ip-version auto --config ${FILE_PATH}/tunnel.yml run`;
      } else {
          args = `tunnel --edge-ip-version auto --no-autoupdate --protocol http2 --logfile ${bootLogPath} --loglevel info --url http://localhost:${ARGO_PORT}`;
      }
      exec(`nohup ${botPath} ${args} >/dev/null 2>&1 &`).then(() => console.log(`${botName} (Argo) is running`)).catch(e => console.error(`argo error: ${e}`));
  }
}

// 提取 Argo 域名
async function extractDomains() {
  if (ARGO_AUTH && ARGO_DOMAIN) {
      await generateLinks(ARGO_DOMAIN);
  } else {
      // 临时隧道逻辑
      await new Promise(r => setTimeout(r, 5000)); // 等待日志生成
      try {
          if(!fs.existsSync(bootLogPath)) return;
          const content = fs.readFileSync(bootLogPath, 'utf-8');
          const match = content.match(/https?:\/\/([^ ]*trycloudflare\.com)/);
          if (match) {
              console.log('ArgoDomain:', match[1]);
              await generateLinks(match[1]);
          } else {
              console.log('Argo domain not found in logs.');
          }
      } catch (e) { console.error(e); }
  }
}

// 生成节点链接
async function generateLinks(argoDomain) {
    const metaInfo = execSync('curl -sm 5 https://speed.cloudflare.com/meta | awk -F\\" \'{print $26"-"$18}\' | sed -e \'s/ /_/g\'', { encoding: 'utf-8' }).trim();
    const nodeName = NAME ? `${NAME}-${metaInfo}` : metaInfo;
    
    const VMESS = { v: '2', ps: `${nodeName}`, add: CFIP, port: CFPORT, id: UUID, aid: '0', scy: 'none', net: 'ws', type: 'none', host: argoDomain, path: '/vmess-argo?ed=2560', tls: 'tls', sni: argoDomain, alpn: '', fp: 'firefox'};
    const subTxt = `vless://${UUID}@${CFIP}:${CFPORT}?encryption=none&security=tls&sni=${argoDomain}&fp=firefox&type=ws&host=${argoDomain}&path=%2Fvless-argo%3Fed%3D2560#${nodeName}\nvmess://${Buffer.from(JSON.stringify(VMESS)).toString('base64')}\ntrojan://${UUID}@${CFIP}:${CFPORT}?security=tls&sni=${argoDomain}&fp=firefox&type=ws&host=${argoDomain}&path=%2Ftrojan-argo%3Fed%3D2560#${nodeName}`;
    
    console.log('\n' + Buffer.from(subTxt).toString('base64') + '\n');
    fs.writeFileSync(subPath, Buffer.from(subTxt).toString('base64'));
    
    app.get(`/${SUB_PATH}`, (req, res) => {
        res.send(Buffer.from(subTxt).toString('base64'));
    });
    
    await uploadNodes();
}

// 上传逻辑
async function uploadNodes() {
    if (!UPLOAD_URL) return;
    try {
        if (PROJECT_URL) {
            await axios.post(`${UPLOAD_URL}/api/add-subscriptions`, { subscription: [`${PROJECT_URL}/${SUB_PATH}`] });
        } else if (fs.existsSync(listPath)) {
            const nodes = fs.readFileSync(listPath, 'utf-8').split('\n').filter(l => l.includes('://'));
            if(nodes.length) await axios.post(`${UPLOAD_URL}/api/add-nodes`, JSON.stringify({ nodes }), { headers: {'Content-Type': 'application/json'} });
        }
        console.log('Uploaded successfully');
    } catch (e) { /* ignore */ }
}

// 90秒后清理
setTimeout(() => {
    [bootLogPath, configPath, webPath, botPath, npmPath, phpPath].forEach(f => {
        if(fs.existsSync(f)) fs.unlinkSync(f);
    });
    console.log('App is running. Cleaned up temp files.');
}, 90000);

// --------------------------------------------------------------------------------
// [功能 2] 彻底移除了 AddVisitTask (保活) 函数及调用
// --------------------------------------------------------------------------------

async function startserver() {
  try {
    deleteNodes();
    cleanupOldFiles();
    await generateConfig();
    await downloadFilesAndRun();
    await extractDomains();
    // 任务完成
  } catch (error) {
    console.error('Error in startserver:', error);
  }
}

startserver();

app.listen(PORT, () => console.log(`Server running on port:${PORT}`));
